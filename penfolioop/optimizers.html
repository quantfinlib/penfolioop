<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>penfolioop.optimizers API documentation</title>
<meta name="description" content="Portfolio optimization and objective functions …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>penfolioop.optimizers</code></h1>
</header>
<section id="section-intro">
<p>Portfolio optimization and objective functions.</p>
<p>This module provides various objective functions for pension fund portfolio optimization, including:</p>
<ul>
<li><code><a title="penfolioop.optimizers.max_surplus_sharpe_ratio_optimizer" href="#penfolioop.optimizers.max_surplus_sharpe_ratio_optimizer">max_surplus_sharpe_ratio_optimizer()</a></code>: </li>
</ul>
<p>This function Maximizes the surplus portfolio return to surplus portfolio risk.</p>
<ul>
<li><code><a title="penfolioop.optimizers.surplus_mean_variance_optimizer" href="#penfolioop.optimizers.surplus_mean_variance_optimizer">surplus_mean_variance_optimizer()</a></code>: </li>
</ul>
<p>Mean-variance optimization for surplus portfolios.</p>
<ul>
<li><code><a title="penfolioop.optimizers.max_surplus_return_optimizer" href="#penfolioop.optimizers.max_surplus_return_optimizer">max_surplus_return_optimizer()</a></code>: </li>
</ul>
<p>Maximizes surplus return with the option of an upper limit on the surplus variance.</p>
<ul>
<li><code><a title="penfolioop.optimizers.min_surplus_variance_optimizer" href="#penfolioop.optimizers.min_surplus_variance_optimizer">min_surplus_variance_optimizer()</a></code>: </li>
</ul>
<p>Minimizes surplus variance with the option of a lower limit on the surplus return.</p>
<ul>
<li><code><a title="penfolioop.optimizers.efficient_frontier" href="#penfolioop.optimizers.efficient_frontier">efficient_frontier()</a></code>: </li>
</ul>
<p>Finds the efficient frontier portfolios.</p>
<p>In all these problems, we aim to find the weight vector that optimally allocates assets in the portfolio.
The weight vector is always an array of asset weights plus a liability weight (the last element of the weight vector),
where the liability weight is always set to -1. </p>
<p>Let's assume that we have $n_{assets}$ in our portfolio. Therefore, the weight vector
is a $n_{assets} + 1$ dimensional vector, where the first $n_{assets}$ elements are the asset weights
and the last element is the liability weight.</p>
<p><span><span class="MathJax_Preview">
\mathbf{w} = \begin{bmatrix}
w_1 \\
w_2 \\
\vdots \\
w_{n_{assets}} \\
w_L
\end{bmatrix} = \begin{bmatrix}
w_1 \\
w_2 \\
\vdots \\
w_{n_{assets}} \\
-1
\end{bmatrix}
</span><script type="math/tex; mode=display">
\mathbf{w} = \begin{bmatrix}
w_1 \\
w_2 \\
\vdots \\
w_{n_{assets}} \\
w_L
\end{bmatrix} = \begin{bmatrix}
w_1 \\
w_2 \\
\vdots \\
w_{n_{assets}} \\
-1
\end{bmatrix}
</script></span>, </p>
<p>where <span><span class="MathJax_Preview"> w_i </span><script type="math/tex"> w_i </script></span> is the weight of asset <span><span class="MathJax_Preview"> i </span><script type="math/tex"> i </script></span> and <span><span class="MathJax_Preview"> w_L </span><script type="math/tex"> w_L </script></span> is the weight of the liabilities, which is set to -1.</p>
<p>In a similar fashion, we define the expected return vector as an array containing the
expected returns of the assets and liabilities. This is a <span><span class="MathJax_Preview">n_{assets} + 1</span><script type="math/tex">n_{assets} + 1</script></span> dimensional vector,
where the first <span><span class="MathJax_Preview">n_{assets}</span><script type="math/tex">n_{assets}</script></span> elements are the expected returns of the assets and the
last element is the expected return of the liabilities.</p>
<p><span><span class="MathJax_Preview">
\mathbf{R} = \begin{bmatrix}
r_1 \\
r_2 \\
\vdots \\
r_n \\
r_L
\end{bmatrix},
</span><script type="math/tex; mode=display">
\mathbf{R} = \begin{bmatrix}
r_1 \\
r_2 \\
\vdots \\
r_n \\
r_L
\end{bmatrix},
</script></span></p>
<p>where <span><span class="MathJax_Preview"> r_i </span><script type="math/tex"> r_i </script></span> is the expected return of asset <span><span class="MathJax_Preview"> i </span><script type="math/tex"> i </script></span> and <span><span class="MathJax_Preview"> r_L </span><script type="math/tex"> r_L </script></span> is the expected return of the liabilities.</p>
<p>The covariance matrix is defined as the covariance matrix of assets and liability returns.
This matrix is a <span><span class="MathJax_Preview">n_{assets} + 1</span><script type="math/tex">n_{assets} + 1</script></span> by <span><span class="MathJax_Preview">n_{assets} + 1</span><script type="math/tex">n_{assets} + 1</script></span> square matrix, where the first <span><span class="MathJax_Preview">n_{assets}</span><script type="math/tex">n_{assets}</script></span>
rows and columns correspond to the assets and the last row and column correspond to the liabilities.</p>
<p><span><span class="MathJax_Preview">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} , \Sigma_{AL} \\
\Sigma_{AL} , \sigma^{2}_{L}
\end{bmatrix},
</span><script type="math/tex; mode=display">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} , \Sigma_{AL} \\
\Sigma_{AL} , \sigma^{2}_{L}
\end{bmatrix},
</script></span></p>
<p>where <span><span class="MathJax_Preview"> \Sigma_{A} </span><script type="math/tex"> \Sigma_{A} </script></span> is a covariance matrix of the assets,
<span><span class="MathJax_Preview"> \Sigma_{AL} </span><script type="math/tex"> \Sigma_{AL} </script></span> is the covariance between the assets and liabilities,
and <span><span class="MathJax_Preview"> \sigma^{2}_{L} </span><script type="math/tex"> \sigma^{2}_{L} </script></span> is the variance of the liabilities.
<span><span class="MathJax_Preview"> \Sigma_{A} </span><script type="math/tex"> \Sigma_{A} </script></span> is a <span><span class="MathJax_Preview">n_{assets}</span><script type="math/tex">n_{assets}</script></span> by <span><span class="MathJax_Preview">n_{assets}</span><script type="math/tex">n_{assets}</script></span> square matrix, where each element
represents the covariance between the returns of two assets.
<span><span class="MathJax_Preview"> \Sigma_{AL} </span><script type="math/tex"> \Sigma_{AL} </script></span> is a <span><span class="MathJax_Preview">n_{assets}</span><script type="math/tex">n_{assets}</script></span> dimensional vector, where each element represents the
covariance between the returns of an asset and liability return.
<span><span class="MathJax_Preview"> \sigma^{2}_{L} </span><script type="math/tex"> \sigma^{2}_{L} </script></span> is the variance of the liability return.</p>
<p>With these conventions at hand, we can compute the surplus return (return of the portfolio in excess of liabilities)
and the surplus variance (variance of the surplus returns) in the following way.</p>
<p><span><span class="MathJax_Preview">
\begin{align*}
\text{Surplus Return} &amp;= \mathbf{W}^{T} \mathbf{R}
= \sum_{i=1}^{n_{assets}} w_{i} r_{i} - r_{L} \\
\text{Surplus Variance} &amp;= \mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W}
= \sum_{i=1}^{n_{assets}} \sum_{j=1}^{n_{assets}} w_{i} w_{j} \big(\Sigma_{A}\big)_{ij} - 2 \sum_{i=1}^{n_{assets}} w_{i} \big(\Sigma_{AL}\big)_{i} + \sigma^{2}_{L}
\end{align*}
</span><script type="math/tex; mode=display">
\begin{align*}
\text{Surplus Return} &= \mathbf{W}^{T} \mathbf{R}
= \sum_{i=1}^{n_{assets}} w_{i} r_{i} - r_{L} \\
\text{Surplus Variance} &= \mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W}
= \sum_{i=1}^{n_{assets}} \sum_{j=1}^{n_{assets}} w_{i} w_{j} \big(\Sigma_{A}\big)_{ij} - 2 \sum_{i=1}^{n_{assets}} w_{i} \big(\Sigma_{AL}\big)_{i} + \sigma^{2}_{L}
\end{align*}
</script></span></p>
<p>For the sake of clarity on the conventions used in this module, we repeat some of these definitions in the documentation of individual functions.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="penfolioop.optimizers.clean_up_weight_decorator"><code class="name flex">
<span>def <span class="ident">clean_up_weight_decorator</span></span>(<span>func: Callable[..., np.ndarray]) ‑> Callable[..., numpy.ndarray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_up_weight_decorator(func: Callable[..., np.ndarray]) -&gt; Callable[..., np.ndarray]:
    &#34;&#34;&#34;Make a decorator to clean up weights after optimization.

    Parameters
    ----------
    func : callable
        The optimization function to decorate.

    Returns
    -------
    callable
        The decorated optimization function.
    &#34;&#34;&#34;

    @wraps(func)
    def wrapper(*args, **kwargs):  # noqa: ANN002, ANN003, ANN202
        # Call the original optimization function
        result = func(*args, **kwargs)
        return _clean_up_weights(result)
    return wrapper</code></pre>
</details>
<div class="desc"><p>Make a decorator to clean up weights after optimization.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>func</code></strong> :&ensp;<code>callable</code></dt>
<dd>The optimization function to decorate.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>callable</code></dt>
<dd>The decorated optimization function.</dd>
</dl></div>
</dd>
<dt id="penfolioop.optimizers.efficient_frontier"><code class="name flex">
<span>def <span class="ident">efficient_frontier</span></span>(<span>portfolio: Portfolio,<br>asset_constraints: list[dict[str, Any]] | None = None,<br>surplus_return_range: tuple[float, float] = (0, 1)) ‑> dict[str, np.ndarray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def efficient_frontier(
    portfolio: Portfolio,
    asset_constraints: list[dict[str, Any]] | None = None,
    surplus_return_range: tuple[float, float] = (0, 1),
) -&gt; dict[str, np.ndarray]:
    r&#34;&#34;&#34;Find the efficient frontier of the portfolio.

    This function calculates the weights of the following optimization problem by
    varying the surplus return lower limit $\tilde{R}$.

    $$
    \underset{\mathbf{W}}{\text{minimize}} \quad \mathbf{W}^{T} \mathbf{C} \mathbf{W}
    $$
    subject to

    $$
    \mathbf{W}^{T} \mathbf{R} \geq \tilde{R}.
    $$

    By varying the surplus return lower limit, we get a different set of weights (different portfolios).
    The set of all these optimal portfolios forms the efficient frontier.

    Note that

    $$
    \begin{align*}
    \mathbf{W} &amp;=&amp; \big[  w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
    \mathbf{R} &amp;=&amp; \big[  R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
    \end{align*} \\
    $$

    $$
    \mathbf{\Sigma} = \begin{bmatrix}
    \Sigma_{A} &amp; \Sigma_{AL} \\
    \Sigma_{AL} &amp; \sigma^{2}_{L}
    \end{bmatrix},
    $$

    where $\mathbf{W}$ is the vector of assets and liability weights, $\mathbf{R}$ is the vector of expected returns
    for the assets and liabilities, and $\mathbf{\Sigma}$ is the covariance matrix of the assets and liabilities.
    The last element of $\mathbf{W}$ corresponds to the liabilities. The liability weight is always set to -1.

    As always, the following general constraints apply to the weights:

    $$
    \begin{align*}
    (1) &amp;\quad&amp; \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
    (2) &amp;\quad&amp; w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
    (3) &amp;\quad&amp; w_{n_{assets} + 1} = w_{L} = -1
    \end{align*}
    $$

    If additional asset constraints are provided, they will be incorporated into the optimization problem.
    See `penfolioop.constraints` for more details.

    Parameters
    ----------
    portfolio : Portfolio
        The portfolio object containing asset names, covariance matrix, expected returns.
    asset_constraints : list[dict[str, Any]], optional
        Additional constraints for the optimization problem. Default is None.
    surplus_return_range : tuple[float, float], optional
        Range of surplus return values to consider for the optimization. Default is (0, 1).

    Returns
    -------
    dict
        Dictionary containing arrays of weights, surplus returns, and surplus variances.
    &#34;&#34;&#34;
    target_returns = np.linspace(surplus_return_range[0], surplus_return_range[1], 100)
    weights_placeholder = []
    surplus_return_place_holder = []
    surplus_variance_place_holder = []
    for target_return in target_returns:
        weights = min_surplus_variance_optimizer(
            portfolio=portfolio,
            asset_constraints=asset_constraints,
            surplus_return_lower_limit=target_return,
        )
        weights_placeholder.append(weights)
        surplus_return_place_holder.append(portfolio.surplus_return(weights))
        surplus_variance_place_holder.append(portfolio.surplus_variance(weights))

    return {
        &#34;weights&#34;: np.array(weights_placeholder),
        &#34;surplus_returns&#34;: np.array(surplus_return_place_holder),
        &#34;surplus_variances&#34;: np.array(surplus_variance_place_holder)
    }</code></pre>
</details>
<div class="desc"><p>Find the efficient frontier of the portfolio.</p>
<p>This function calculates the weights of the following optimization problem by
varying the surplus return lower limit $\tilde{R}$.</p>
<p><span><span class="MathJax_Preview">
\underset{\mathbf{W}}{\text{minimize}} \quad \mathbf{W}^{T} \mathbf{C} \mathbf{W}
</span><script type="math/tex; mode=display">
\underset{\mathbf{W}}{\text{minimize}} \quad \mathbf{W}^{T} \mathbf{C} \mathbf{W}
</script></span>
subject to</p>
<p><span><span class="MathJax_Preview">
\mathbf{W}^{T} \mathbf{R} \geq \tilde{R}.
</span><script type="math/tex; mode=display">
\mathbf{W}^{T} \mathbf{R} \geq \tilde{R}.
</script></span></p>
<p>By varying the surplus return lower limit, we get a different set of weights (different portfolios).
The set of all these optimal portfolios forms the efficient frontier.</p>
<p>Note that</p>
<p><span><span class="MathJax_Preview">
\begin{align*}
\mathbf{W} &amp;=&amp; \big[
w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
\mathbf{R} &amp;=&amp; \big[
R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
\end{align*} \\
</span><script type="math/tex; mode=display">
\begin{align*}
\mathbf{W} &=& \big[
w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
\mathbf{R} &=& \big[
R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
\end{align*} \\
</script></span></p>
<p><span><span class="MathJax_Preview">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} &amp; \Sigma_{AL} \\
\Sigma_{AL} &amp; \sigma^{2}_{L}
\end{bmatrix},
</span><script type="math/tex; mode=display">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} & \Sigma_{AL} \\
\Sigma_{AL} & \sigma^{2}_{L}
\end{bmatrix},
</script></span></p>
<p>where $\mathbf{W}$ is the vector of assets and liability weights, $\mathbf{R}$ is the vector of expected returns
for the assets and liabilities, and $\mathbf{\Sigma}$ is the covariance matrix of the assets and liabilities.
The last element of $\mathbf{W}$ corresponds to the liabilities. The liability weight is always set to -1.</p>
<p>As always, the following general constraints apply to the weights:</p>
<p><span><span class="MathJax_Preview">
\begin{align*}
(1) &amp;\quad&amp; \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
(2) &amp;\quad&amp; w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
(3) &amp;\quad&amp; w_{n_{assets} + 1} = w_{L} = -1
\end{align*}
</span><script type="math/tex; mode=display">
\begin{align*}
(1) &\quad& \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
(2) &\quad& w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
(3) &\quad& w_{n_{assets} + 1} = w_{L} = -1
\end{align*}
</script></span></p>
<p>If additional asset constraints are provided, they will be incorporated into the optimization problem.
See <code><a title="penfolioop.constraints" href="constraints.html">penfolioop.constraints</a></code> for more details.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>portfolio</code></strong> :&ensp;<code>Portfolio</code></dt>
<dd>The portfolio object containing asset names, covariance matrix, expected returns.</dd>
<dt><strong><code>asset_constraints</code></strong> :&ensp;<code>list[dict[str, Any]]</code>, optional</dt>
<dd>Additional constraints for the optimization problem. Default is None.</dd>
<dt><strong><code>surplus_return_range</code></strong> :&ensp;<code>tuple[float, float]</code>, optional</dt>
<dd>Range of surplus return values to consider for the optimization. Default is (0, 1).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Dictionary containing arrays of weights, surplus returns, and surplus variances.</dd>
</dl></div>
</dd>
<dt id="penfolioop.optimizers.max_surplus_return_optimizer"><code class="name flex">
<span>def <span class="ident">max_surplus_return_optimizer</span></span>(<span>portfolio: Portfolio,<br>asset_constraints: list[dict[str, Any]] | None = None,<br>surplus_risk_upper_limit: float | None = None) ‑> np.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@clean_up_weight_decorator
def max_surplus_return_optimizer(
    portfolio: Portfolio,
    asset_constraints: list[dict[str, Any]] | None = None,
    surplus_risk_upper_limit: float | None = None,
) -&gt; np.ndarray:
    r&#34;&#34;&#34;Optimize the asset weights to maximize the surplus return over the expected liabilities return.

    The optimization problem can be formulated as:
    $$
    \underset{\mathbf{W}}{\mathrm{maximize}} \quad \mathbf{W}^{T}\mathbf{R},
    $$

    $$
    \begin{align*}
    \mathbf{W} &amp;=&amp; \big[  w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
    \mathbf{R} &amp;=&amp; \big[  R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
    \end{align*} \\
    $$

    $$
    \mathbf{\Sigma} = \begin{bmatrix}
    \Sigma_{A} &amp; \Sigma_{AL} \\
    \Sigma_{AL} &amp; \sigma^{2}_{L}
    \end{bmatrix},
    $$

    where $\mathbf{W}$ is the vector of assets and liability weights, $\mathbf{R}$ is the vector of expected returns
    for the assets and liabilities, and $\mathbf{\Sigma}$ is the covariance matrix of the assets and liabilities.

    The last element of $\mathbf{W}$ corresponds to the liabilities. The liability weight is always set to -1.


    The optimization is subject to the following constraints:

    $$
    \begin{align*}
    (1) &amp;\quad&amp; \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
    (2) &amp;\quad&amp; w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
    (3) &amp;\quad&amp; w_{n_{assets} + 1} = w_{L} = -1
    \end{align*}
    $$

    Additionally, if the parameter `surplus_risk_upper_limit` is provided by the user, we will add a surplus risk upper limit
    constraint to the optimization problem:

    $$
    \mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W} \leq \sigma^2
    $$, where $\sigma$ is the surplus risk upper limit.


    If the `asset_constraints` parameter is provided by the user, the optimization will include these additional
    constraints. See `penfolioop.constraints` for more details. A valid `asset_constraints` must fulfill a set
    of properties which are validated by the `penfolioop.constraints.AssetConstraint` class. Users are encouraged
    to consult with the `penfolioop.constraints` module and in particular the `penfolioop.constraints.AssetConstraint`
    class for more information on how to properly define asset constraints.

    Parameters
    ----------
    portfolio : Portfolio
        The portfolio object containing asset names, covariance matrix, expected returns.
    asset_constraints : list[dict[str, Any]], optional
        Additional constraints for the optimization problem. Default is None.
    surplus_risk_upper_limit : float, optional
        The surplus risk upper limit for the optimization problem. Default is None.

    Returns
    -------
    np.ndarray
        Optimized asset weights as a numpy array.

    Raises
    ------
    ValueError
        If the optimization fails or constraints are not satisfied.

    &#34;&#34;&#34;
    n_assets = len(portfolio.names) - 1
    weights = cp.Variable(n_assets + 1)

    # Objective function: maximize the surplus return over the expected liabilities return
    surplus_return = weights.T @ portfolio.expected_returns
    objective = cp.Maximize(surplus_return)
    # Constraints
    constraints = [
        cp.sum(weights[:n_assets]) == 1,  # Weights must sum to 1
        weights[:n_assets] &gt;= 0,          # No short selling
        weights[-1] == -1,                # Last weight is liabilities
    ]
    # Apply asset constraints if provided by user
    if asset_constraints:
        constraints += generate_constraints(
            portfolio_weights=weights, asset_constraints=asset_constraints, asset_names=portfolio.names
        )
    # Surplus risk upper limit constraint if provided by user
    if surplus_risk_upper_limit is not None:
        constraints.append(cp.quad_form(weights, portfolio.covariance_matrix) &lt;= surplus_risk_upper_limit ** 2.)
    # Solve the optimization problem
    problem = cp.Problem(objective, constraints)
    problem.solve()

    if weights.value is None or problem.status != cp.OPTIMAL:
        msg = &#34;Optimization failed.&#34;
        raise ValueError(msg)

    return weights.value</code></pre>
</details>
<div class="desc"><p>Optimize the asset weights to maximize the surplus return over the expected liabilities return.</p>
<p>The optimization problem can be formulated as:
<span><span class="MathJax_Preview">
\underset{\mathbf{W}}{\mathrm{maximize}} \quad \mathbf{W}^{T}\mathbf{R},
</span><script type="math/tex; mode=display">
\underset{\mathbf{W}}{\mathrm{maximize}} \quad \mathbf{W}^{T}\mathbf{R},
</script></span></p>
<p><span><span class="MathJax_Preview">
\begin{align*}
\mathbf{W} &amp;=&amp; \big[
w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
\mathbf{R} &amp;=&amp; \big[
R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
\end{align*} \\
</span><script type="math/tex; mode=display">
\begin{align*}
\mathbf{W} &=& \big[
w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
\mathbf{R} &=& \big[
R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
\end{align*} \\
</script></span></p>
<p><span><span class="MathJax_Preview">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} &amp; \Sigma_{AL} \\
\Sigma_{AL} &amp; \sigma^{2}_{L}
\end{bmatrix},
</span><script type="math/tex; mode=display">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} & \Sigma_{AL} \\
\Sigma_{AL} & \sigma^{2}_{L}
\end{bmatrix},
</script></span></p>
<p>where $\mathbf{W}$ is the vector of assets and liability weights, $\mathbf{R}$ is the vector of expected returns
for the assets and liabilities, and $\mathbf{\Sigma}$ is the covariance matrix of the assets and liabilities.</p>
<p>The last element of $\mathbf{W}$ corresponds to the liabilities. The liability weight is always set to -1.</p>
<p>The optimization is subject to the following constraints:</p>
<p><span><span class="MathJax_Preview">
\begin{align*}
(1) &amp;\quad&amp; \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
(2) &amp;\quad&amp; w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
(3) &amp;\quad&amp; w_{n_{assets} + 1} = w_{L} = -1
\end{align*}
</span><script type="math/tex; mode=display">
\begin{align*}
(1) &\quad& \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
(2) &\quad& w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
(3) &\quad& w_{n_{assets} + 1} = w_{L} = -1
\end{align*}
</script></span></p>
<p>Additionally, if the parameter <code>surplus_risk_upper_limit</code> is provided by the user, we will add a surplus risk upper limit
constraint to the optimization problem:</p>
<p><span><span class="MathJax_Preview">
\mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W} \leq \sigma^2
</span><script type="math/tex; mode=display">
\mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W} \leq \sigma^2
</script></span>, where $\sigma$ is the surplus risk upper limit.</p>
<p>If the <code>asset_constraints</code> parameter is provided by the user, the optimization will include these additional
constraints. See <code><a title="penfolioop.constraints" href="constraints.html">penfolioop.constraints</a></code> for more details. A valid <code>asset_constraints</code> must fulfill a set
of properties which are validated by the <code><a title="penfolioop.constraints.AssetConstraint" href="constraints.html#penfolioop.constraints.AssetConstraint">AssetConstraint</a></code> class. Users are encouraged
to consult with the <code><a title="penfolioop.constraints" href="constraints.html">penfolioop.constraints</a></code> module and in particular the <code><a title="penfolioop.constraints.AssetConstraint" href="constraints.html#penfolioop.constraints.AssetConstraint">AssetConstraint</a></code>
class for more information on how to properly define asset constraints.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>portfolio</code></strong> :&ensp;<code>Portfolio</code></dt>
<dd>The portfolio object containing asset names, covariance matrix, expected returns.</dd>
<dt><strong><code>asset_constraints</code></strong> :&ensp;<code>list[dict[str, Any]]</code>, optional</dt>
<dd>Additional constraints for the optimization problem. Default is None.</dd>
<dt><strong><code>surplus_risk_upper_limit</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The surplus risk upper limit for the optimization problem. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Optimized asset weights as a numpy array.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optimization fails or constraints are not satisfied.</dd>
</dl></div>
</dd>
<dt id="penfolioop.optimizers.max_surplus_sharpe_ratio_optimizer"><code class="name flex">
<span>def <span class="ident">max_surplus_sharpe_ratio_optimizer</span></span>(<span>portfolio: Portfolio, asset_constraints: list[dict[str, Any]] | None = None) ‑> np.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@clean_up_weight_decorator
def max_surplus_sharpe_ratio_optimizer(
    portfolio: Portfolio, asset_constraints: list[dict[str, Any]] | None = None,
) -&gt; np.ndarray:
    r&#34;&#34;&#34;Optimize the asset weights to achieve a target excess return over the expected liabilities return.

    This problem can be formulated as:

    $$
    \underset{\mathbf{W}}{\mathrm{maximize}} \quad  \frac{\mathbf{W}^{T}\mathbf{R}}{\mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W}},
    $$


    $$
    \begin{align*}
    \mathbf{W} &amp;=&amp; \big[  w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
    \mathbf{R} &amp;=&amp; \big[  R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
    \end{align*} \\
    $$

    $$
    \mathbf{\Sigma} = \begin{bmatrix}
    \Sigma_{A} &amp; \Sigma_{AL} \\
    \Sigma_{AL} &amp; \sigma^{2}_{L}
    \end{bmatrix},
    $$

    where $\mathbf{W}$ is the vector of assets and liability weights, $\mathbf{R}$ is the vector of expected returns
    for the assets and liabilities, and $\mathbf{\Sigma}$ is the covariance matrix of the assets and liabilities.

    The last element of $\mathbf{W}$ corresponds to the liabilities. The liability weight is always set to -1.


    The optimization is subject to the following constraints:

    $$
    \begin{align*}
    (1) &amp;\quad&amp; \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
    (2) &amp;\quad&amp; w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
    (3) &amp;\quad&amp; w_{n_{assets} + 1} = w_{L} = -1
    \end{align*}
    $$

    If the `asset_constraints` parameter is provided by the user, the optimization will include these additional constraints.
    See `penfolioop.constraints` for more details. A valid `asset_constraints` must fullfill a set of properties which are validated
    by the `penfolioop.constraints.AssetConstraint` class. Users are encouraged to consult with the `penfolioop.constraints`
    module and in particular the `penfolioop.constraints.AssetConstraint` class for more information on how to properly define asset constraints.

    Parameters
    ----------
    portfolio : Portfolio
        The portfolio object containing asset names, covariance matrix, expected returns.
    asset_constraints : list[dict[str, Any]], optional
        Additional constraints for the optimization problem. Default is None.


    Returns
    -------
    np.ndarray
        Optimized asset weights as a numpy array.

    Raises
    ------
    ValueError
        If the optimization fails or constraints are not satisfied.

    &#34;&#34;&#34;  # noqa: E501
    n_assets = len(portfolio.names) - 1

    # Constraints
    constraints = [
        {&#34;type&#34;: &#34;eq&#34;, &#34;fun&#34;: lambda w: np.sum(w[:n_assets]) - 1},  # weights sum to 1
        {&#34;type&#34;: &#34;eq&#34;, &#34;fun&#34;: lambda w: w[-1] + 1},                 # last weight is -1
    ]
    if asset_constraints:
        constraints += generate_scipy_constraints(
            asset_constraints=asset_constraints, asset_names=portfolio.names,
        )
    # Bounds
    bounds = [(0, 1)] * n_assets + [(None, None)]  # last weight (liability) unbounded
    # Initial guess
    initial_weights = np.ones(n_assets + 1) / (n_assets)
    initial_weights[-1] = -1  # liabilities weight

    # Solve the optimization problem
    result = minimize(
        _negative_surplus_sharpe_ratio_objective,
        initial_weights,
        args=(portfolio.expected_returns, portfolio.covariance_matrix),
        method=&#34;SLSQP&#34;,
        bounds=bounds,
        constraints=constraints
    )
    if not result.success:
        msg = &#34;Optimization failed.&#34;
        raise ValueError(msg)

    return result.x</code></pre>
</details>
<div class="desc"><p>Optimize the asset weights to achieve a target excess return over the expected liabilities return.</p>
<p>This problem can be formulated as:</p>
<p><span><span class="MathJax_Preview">
\underset{\mathbf{W}}{\mathrm{maximize}} \quad
\frac{\mathbf{W}^{T}\mathbf{R}}{\mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W}},
</span><script type="math/tex; mode=display">
\underset{\mathbf{W}}{\mathrm{maximize}} \quad
\frac{\mathbf{W}^{T}\mathbf{R}}{\mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W}},
</script></span></p>
<p><span><span class="MathJax_Preview">
\begin{align*}
\mathbf{W} &amp;=&amp; \big[
w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
\mathbf{R} &amp;=&amp; \big[
R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
\end{align*} \\
</span><script type="math/tex; mode=display">
\begin{align*}
\mathbf{W} &=& \big[
w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
\mathbf{R} &=& \big[
R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
\end{align*} \\
</script></span></p>
<p><span><span class="MathJax_Preview">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} &amp; \Sigma_{AL} \\
\Sigma_{AL} &amp; \sigma^{2}_{L}
\end{bmatrix},
</span><script type="math/tex; mode=display">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} & \Sigma_{AL} \\
\Sigma_{AL} & \sigma^{2}_{L}
\end{bmatrix},
</script></span></p>
<p>where $\mathbf{W}$ is the vector of assets and liability weights, $\mathbf{R}$ is the vector of expected returns
for the assets and liabilities, and $\mathbf{\Sigma}$ is the covariance matrix of the assets and liabilities.</p>
<p>The last element of $\mathbf{W}$ corresponds to the liabilities. The liability weight is always set to -1.</p>
<p>The optimization is subject to the following constraints:</p>
<p><span><span class="MathJax_Preview">
\begin{align*}
(1) &amp;\quad&amp; \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
(2) &amp;\quad&amp; w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
(3) &amp;\quad&amp; w_{n_{assets} + 1} = w_{L} = -1
\end{align*}
</span><script type="math/tex; mode=display">
\begin{align*}
(1) &\quad& \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
(2) &\quad& w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
(3) &\quad& w_{n_{assets} + 1} = w_{L} = -1
\end{align*}
</script></span></p>
<p>If the <code>asset_constraints</code> parameter is provided by the user, the optimization will include these additional constraints.
See <code><a title="penfolioop.constraints" href="constraints.html">penfolioop.constraints</a></code> for more details. A valid <code>asset_constraints</code> must fullfill a set of properties which are validated
by the <code><a title="penfolioop.constraints.AssetConstraint" href="constraints.html#penfolioop.constraints.AssetConstraint">AssetConstraint</a></code> class. Users are encouraged to consult with the <code><a title="penfolioop.constraints" href="constraints.html">penfolioop.constraints</a></code>
module and in particular the <code><a title="penfolioop.constraints.AssetConstraint" href="constraints.html#penfolioop.constraints.AssetConstraint">AssetConstraint</a></code> class for more information on how to properly define asset constraints.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>portfolio</code></strong> :&ensp;<code>Portfolio</code></dt>
<dd>The portfolio object containing asset names, covariance matrix, expected returns.</dd>
<dt><strong><code>asset_constraints</code></strong> :&ensp;<code>list[dict[str, Any]]</code>, optional</dt>
<dd>Additional constraints for the optimization problem. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Optimized asset weights as a numpy array.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optimization fails or constraints are not satisfied.</dd>
</dl></div>
</dd>
<dt id="penfolioop.optimizers.min_surplus_variance_optimizer"><code class="name flex">
<span>def <span class="ident">min_surplus_variance_optimizer</span></span>(<span>portfolio: Portfolio,<br>asset_constraints: list[dict[str, Any]] | None = None,<br>surplus_return_lower_limit: float | None = None) ‑> np.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@clean_up_weight_decorator
def min_surplus_variance_optimizer(
    portfolio: Portfolio, 
    asset_constraints: list[dict[str, Any]] | None = None,
    surplus_return_lower_limit: float | None = None,
) -&gt; np.ndarray:
    r&#34;&#34;&#34;Optimize the asset weights to minimize the surplus variance of the portfolio.

    This optimization problem can be formulated as:

    $$
    \underset{\mathbf{W}}{\mathrm{minimize}} \quad \mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W},
    $$

    $$
    \begin{align*}
    \mathbf{W} &amp;=&amp; \big[  w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
    \mathbf{R} &amp;=&amp; \big[  R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
    \end{align*} \\
    $$

    $$
    \mathbf{\Sigma} = \begin{bmatrix}
    \Sigma_{A} &amp; \Sigma_{AL} \\
    \Sigma_{AL} &amp; \sigma^{2}_{L}
    \end{bmatrix},
    $$

    where $\mathbf{W}$ is the vector of assets and liability weights, $\mathbf{R}$ is the vector of expected returns
    for the assets and liabilities, and $\mathbf{\Sigma}$ is the covariance matrix of the assets and liabilities.

    The last element of $\mathbf{W}$ corresponds to the liabilities. The liability weight is always set to -1.

    The optimization is subject to the following general constraints:

    $$
    \begin{align*}
    (1) &amp;\quad&amp; \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
    (2) &amp;\quad&amp; w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
    (3) &amp;\quad&amp; w_{n_{assets} + 1} = w_{L} = -1
    \end{align*}
    $$

    Additionally, if the parameter `surplus_return_lower_limit` is provided by the user, 
    we will add a surplus return lower limit constraint to the optimization problem:

    $$
    \mathbf{W}^{T} \mathbf{R} \geq \tilde{R}
    $$,

    where $\tilde{R}$ is the surplus return lower limit.


    If the `asset_constraints` parameter is provided by the user, the optimization will include these
    additional constraints. See `penfolioop.constraints` for more details. A valid `asset_constraints`
    must fullfill a set of properties which are validated by the `penfolioop.constraints.AssetConstraint` class.
    Users are encouraged to consult with the `penfolioop.constraints` module and in particular the 
    `penfolioop.constraints.AssetConstraint` class for more information on how to properly define asset constraints.


    Parameters
    ----------
    portfolio : Portfolio
        The portfolio object containing asset names, covariance matrix, expected returns.
    asset_constraints : list[dict[str, Any]], optional
        Additional constraints for the optimization problem. Default is None.
    surplus_return_lower_limit : float, optional
        The surplus return lower limit for the optimization problem. Default is None.

    Returns
    -------
    np.ndarray
        Optimized asset weights as a numpy array.

    Raises
    ------
    ValueError
        If the optimization fails or constraints are not satisfied.

    &#34;&#34;&#34;
    n_assets = len(portfolio.names) - 1
    weights = cp.Variable(n_assets + 1)

    # Objective function: minimize the surplus variance of the portfolio
    surplus_variance = cp.quad_form(weights, portfolio.covariance_matrix)
    objective = cp.Minimize(surplus_variance)
    # Constraints
    constraints = [
        cp.sum(weights[:n_assets]) == 1,  # Weights must sum to 1
        weights[:n_assets] &gt;= 0,          # No short selling
        weights[-1] == -1,                # Last weight is liabilities
    ]
    # Apply asset constraints if provided by user
    if asset_constraints:
        constraints += generate_constraints(
            portfolio_weights=weights, asset_constraints=asset_constraints, asset_names=portfolio.names
        )
    # Apply surplus return lower limit constraint if provided by user
    if surplus_return_lower_limit is not None:
        constraints.append(weights.T @ portfolio.expected_returns &gt;= surplus_return_lower_limit)
    # Solve the optimization problem
    problem = cp.Problem(objective, constraints)
    problem.solve()

    if weights.value is None or problem.status != cp.OPTIMAL:
        msg = &#34;Optimization failed&#34;
        raise ValueError(msg)

    return weights.value</code></pre>
</details>
<div class="desc"><p>Optimize the asset weights to minimize the surplus variance of the portfolio.</p>
<p>This optimization problem can be formulated as:</p>
<p><span><span class="MathJax_Preview">
\underset{\mathbf{W}}{\mathrm{minimize}} \quad \mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W},
</span><script type="math/tex; mode=display">
\underset{\mathbf{W}}{\mathrm{minimize}} \quad \mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W},
</script></span></p>
<p><span><span class="MathJax_Preview">
\begin{align*}
\mathbf{W} &amp;=&amp; \big[
w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
\mathbf{R} &amp;=&amp; \big[
R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
\end{align*} \\
</span><script type="math/tex; mode=display">
\begin{align*}
\mathbf{W} &=& \big[
w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
\mathbf{R} &=& \big[
R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
\end{align*} \\
</script></span></p>
<p><span><span class="MathJax_Preview">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} &amp; \Sigma_{AL} \\
\Sigma_{AL} &amp; \sigma^{2}_{L}
\end{bmatrix},
</span><script type="math/tex; mode=display">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} & \Sigma_{AL} \\
\Sigma_{AL} & \sigma^{2}_{L}
\end{bmatrix},
</script></span></p>
<p>where $\mathbf{W}$ is the vector of assets and liability weights, $\mathbf{R}$ is the vector of expected returns
for the assets and liabilities, and $\mathbf{\Sigma}$ is the covariance matrix of the assets and liabilities.</p>
<p>The last element of $\mathbf{W}$ corresponds to the liabilities. The liability weight is always set to -1.</p>
<p>The optimization is subject to the following general constraints:</p>
<p><span><span class="MathJax_Preview">
\begin{align*}
(1) &amp;\quad&amp; \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
(2) &amp;\quad&amp; w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
(3) &amp;\quad&amp; w_{n_{assets} + 1} = w_{L} = -1
\end{align*}
</span><script type="math/tex; mode=display">
\begin{align*}
(1) &\quad& \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
(2) &\quad& w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
(3) &\quad& w_{n_{assets} + 1} = w_{L} = -1
\end{align*}
</script></span></p>
<p>Additionally, if the parameter <code>surplus_return_lower_limit</code> is provided by the user,
we will add a surplus return lower limit constraint to the optimization problem:</p>
<p><span><span class="MathJax_Preview">
\mathbf{W}^{T} \mathbf{R} \geq \tilde{R}
</span><script type="math/tex; mode=display">
\mathbf{W}^{T} \mathbf{R} \geq \tilde{R}
</script></span>,</p>
<p>where $\tilde{R}$ is the surplus return lower limit.</p>
<p>If the <code>asset_constraints</code> parameter is provided by the user, the optimization will include these
additional constraints. See <code><a title="penfolioop.constraints" href="constraints.html">penfolioop.constraints</a></code> for more details. A valid <code>asset_constraints</code>
must fullfill a set of properties which are validated by the <code><a title="penfolioop.constraints.AssetConstraint" href="constraints.html#penfolioop.constraints.AssetConstraint">AssetConstraint</a></code> class.
Users are encouraged to consult with the <code><a title="penfolioop.constraints" href="constraints.html">penfolioop.constraints</a></code> module and in particular the
<code><a title="penfolioop.constraints.AssetConstraint" href="constraints.html#penfolioop.constraints.AssetConstraint">AssetConstraint</a></code> class for more information on how to properly define asset constraints.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>portfolio</code></strong> :&ensp;<code>Portfolio</code></dt>
<dd>The portfolio object containing asset names, covariance matrix, expected returns.</dd>
<dt><strong><code>asset_constraints</code></strong> :&ensp;<code>list[dict[str, Any]]</code>, optional</dt>
<dd>Additional constraints for the optimization problem. Default is None.</dd>
<dt><strong><code>surplus_return_lower_limit</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>The surplus return lower limit for the optimization problem. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Optimized asset weights as a numpy array.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optimization fails or constraints are not satisfied.</dd>
</dl></div>
</dd>
<dt id="penfolioop.optimizers.surplus_mean_variance_optimizer"><code class="name flex">
<span>def <span class="ident">surplus_mean_variance_optimizer</span></span>(<span>portfolio: Portfolio,<br>risk_aversion: float = 1.0,<br>asset_constraints: list[dict[str, Any]] | None = None) ‑> np.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@clean_up_weight_decorator
def surplus_mean_variance_optimizer(
    portfolio: Portfolio, risk_aversion: float = 1., asset_constraints: list[dict[str, Any]] | None = None,
) -&gt; np.ndarray:
    r&#34;&#34;&#34;Optimize the asset weights to maximize the surplus return over the expected liabilities return.

    This optimization problem can be formulated as:

    $$
    \underset{\mathbf{W}}{\mathrm{maximize}} \quad  \mathbf{W}^{T}\mathbf{R} -  \frac{\lambda}{2}  \mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W},
    $$

    $$
    \begin{align*}
    \mathbf{W} &amp;=&amp; \big[  w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
    \mathbf{R} &amp;=&amp; \big[  R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
    \end{align*} \\
    $$

    $$
    \mathbf{\Sigma} = \begin{bmatrix}
    \Sigma_{A} &amp; \Sigma_{AL} \\
    \Sigma_{AL} &amp; \sigma^{2}_{L}
    \end{bmatrix},
    $$

    where $\mathbf{W}$ is the vector of assets and liability weights, $\mathbf{R}$ is the vector of expected returns
    for the assets and liabilities, $\mathbf{\Sigma}$ is the covariance matrix of the assets and liabilities, and $\lambda$
    is the risk aversion parameter.

    The last element of $\mathbf{W}$ corresponds to the liabilities. The liability weight is always set to -1.


    The optimization is subject to the following constraints:

    $$
    \begin{align*}
    (1) &amp;\quad&amp; \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
    (2) &amp;\quad&amp; w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
    (3) &amp;\quad&amp; w_{n_{assets} + 1} = w_{L} = -1
    \end{align*}
    $$

    If the `asset_constraints` parameter is provided by the user, the optimization will include these additional constraints.
    See `penfolioop.constraints` for more details. A valid `asset_constraints` must fullfill a set of properties which are validated
    by the `penfolioop.constraints.AssetConstraint` class. Users are encouraged to consult with the `penfolioop.constraints`
    module and in particular the `penfolioop.constraints.AssetConstraint` class for more information on how to properly define asset constraints.


    Parameters
    ----------
    portfolio : Portfolio
        The portfolio object containing asset names, covariance matrix, expected returns.
    lmbd : float, optional
        Regularization parameter for the optimization problem. Default is 1.0.
    asset_constraints : list[dict[str, Any]], optional
        Additional constraints for the optimization problem. Default is None.

    Returns
    -------
    np.ndarray
        Optimized asset weights as a numpy array.

    Raises
    ------
    ValueError
        If the optimization fails or constraints are not satisfied.

    &#34;&#34;&#34;  # noqa: E501
    if risk_aversion &lt; 0:
        msg = &#34;Risk aversion must be non-negative.&#34;
        raise ValueError(msg)

    n_assets = len(portfolio.names) - 1
    weights = cp.Variable(n_assets + 1)
    # Objective function: maximize the surplus return over the expected liabilities return
    surplus_return = weights.T @ portfolio.expected_returns
    surplus_variance = cp.quad_form(weights, portfolio.covariance_matrix)
    objective = cp.Maximize(surplus_return - risk_aversion / 2 * surplus_variance)
    # Constraints
    constraints = [
        cp.sum(weights[:n_assets]) == 1,  # Weights must sum to 1
        weights[:n_assets] &gt;= 0,          # No short selling
        weights[-1] == -1,                # Last weight is liabilities
    ]
    if asset_constraints:
        constraints += generate_constraints(
            portfolio_weights=weights, asset_constraints=asset_constraints, asset_names=portfolio.names
        )
    # Solve the optimization problem
    problem = cp.Problem(objective, constraints)
    problem.solve()

    if weights.value is None or problem.status != cp.OPTIMAL:
        msg = &#34;Optimization failed.&#34;
        raise ValueError(msg)

    return weights.value</code></pre>
</details>
<div class="desc"><p>Optimize the asset weights to maximize the surplus return over the expected liabilities return.</p>
<p>This optimization problem can be formulated as:</p>
<p><span><span class="MathJax_Preview">
\underset{\mathbf{W}}{\mathrm{maximize}} \quad
\mathbf{W}^{T}\mathbf{R} -
\frac{\lambda}{2}
\mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W},
</span><script type="math/tex; mode=display">
\underset{\mathbf{W}}{\mathrm{maximize}} \quad
\mathbf{W}^{T}\mathbf{R} -
\frac{\lambda}{2}
\mathbf{W}^{T} \mathbf{\Sigma} \mathbf{W},
</script></span></p>
<p><span><span class="MathJax_Preview">
\begin{align*}
\mathbf{W} &amp;=&amp; \big[
w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
\mathbf{R} &amp;=&amp; \big[
R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
\end{align*} \\
</span><script type="math/tex; mode=display">
\begin{align*}
\mathbf{W} &=& \big[
w_{1}, w_{2}, \ldots, w_{n_{assets}}, -1 \big]^{T}, \\
\mathbf{R} &=& \big[
R_{1}, R_{2}, \ldots, R_{n_{assets}}, R_{L} \big]^{T}, \\
\end{align*} \\
</script></span></p>
<p><span><span class="MathJax_Preview">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} &amp; \Sigma_{AL} \\
\Sigma_{AL} &amp; \sigma^{2}_{L}
\end{bmatrix},
</span><script type="math/tex; mode=display">
\mathbf{\Sigma} = \begin{bmatrix}
\Sigma_{A} & \Sigma_{AL} \\
\Sigma_{AL} & \sigma^{2}_{L}
\end{bmatrix},
</script></span></p>
<p>where $\mathbf{W}$ is the vector of assets and liability weights, $\mathbf{R}$ is the vector of expected returns
for the assets and liabilities, $\mathbf{\Sigma}$ is the covariance matrix of the assets and liabilities, and $\lambda$
is the risk aversion parameter.</p>
<p>The last element of $\mathbf{W}$ corresponds to the liabilities. The liability weight is always set to -1.</p>
<p>The optimization is subject to the following constraints:</p>
<p><span><span class="MathJax_Preview">
\begin{align*}
(1) &amp;\quad&amp; \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
(2) &amp;\quad&amp; w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
(3) &amp;\quad&amp; w_{n_{assets} + 1} = w_{L} = -1
\end{align*}
</span><script type="math/tex; mode=display">
\begin{align*}
(1) &\quad& \sum_{i=1}^{n_{assets}} w_{i} = 1, \\
(2) &\quad& w_{i} \geq 0, \quad \forall i \in \{1, \ldots, n_{assets}\}, \\
(3) &\quad& w_{n_{assets} + 1} = w_{L} = -1
\end{align*}
</script></span></p>
<p>If the <code>asset_constraints</code> parameter is provided by the user, the optimization will include these additional constraints.
See <code><a title="penfolioop.constraints" href="constraints.html">penfolioop.constraints</a></code> for more details. A valid <code>asset_constraints</code> must fullfill a set of properties which are validated
by the <code><a title="penfolioop.constraints.AssetConstraint" href="constraints.html#penfolioop.constraints.AssetConstraint">AssetConstraint</a></code> class. Users are encouraged to consult with the <code><a title="penfolioop.constraints" href="constraints.html">penfolioop.constraints</a></code>
module and in particular the <code><a title="penfolioop.constraints.AssetConstraint" href="constraints.html#penfolioop.constraints.AssetConstraint">AssetConstraint</a></code> class for more information on how to properly define asset constraints.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>portfolio</code></strong> :&ensp;<code>Portfolio</code></dt>
<dd>The portfolio object containing asset names, covariance matrix, expected returns.</dd>
<dt><strong><code>lmbd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Regularization parameter for the optimization problem. Default is 1.0.</dd>
<dt><strong><code>asset_constraints</code></strong> :&ensp;<code>list[dict[str, Any]]</code>, optional</dt>
<dd>Additional constraints for the optimization problem. Default is None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Optimized asset weights as a numpy array.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the optimization fails or constraints are not satisfied.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="penfolioop" href="index.html">penfolioop</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="penfolioop.optimizers.clean_up_weight_decorator" href="#penfolioop.optimizers.clean_up_weight_decorator">clean_up_weight_decorator</a></code></li>
<li><code><a title="penfolioop.optimizers.efficient_frontier" href="#penfolioop.optimizers.efficient_frontier">efficient_frontier</a></code></li>
<li><code><a title="penfolioop.optimizers.max_surplus_return_optimizer" href="#penfolioop.optimizers.max_surplus_return_optimizer">max_surplus_return_optimizer</a></code></li>
<li><code><a title="penfolioop.optimizers.max_surplus_sharpe_ratio_optimizer" href="#penfolioop.optimizers.max_surplus_sharpe_ratio_optimizer">max_surplus_sharpe_ratio_optimizer</a></code></li>
<li><code><a title="penfolioop.optimizers.min_surplus_variance_optimizer" href="#penfolioop.optimizers.min_surplus_variance_optimizer">min_surplus_variance_optimizer</a></code></li>
<li><code><a title="penfolioop.optimizers.surplus_mean_variance_optimizer" href="#penfolioop.optimizers.surplus_mean_variance_optimizer">surplus_mean_variance_optimizer</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
